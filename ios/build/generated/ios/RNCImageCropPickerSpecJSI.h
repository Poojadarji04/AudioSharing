/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeImageCropPickerPickerOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19>
struct NativeImageCropPickerPickerOptions {
  P0 mediaType;
  P1 multiple;
  P2 includeBase64;
  P3 includeExif;
  P4 cropping;
  P5 width;
  P6 height;
  P7 cropperActiveWidgetColor;
  P8 cropperStatusBarColor;
  P9 cropperToolbarColor;
  P10 cropperToolbarTitle;
  P11 cropperToolbarWidgetColor;
  P12 cropperCircleOverlay;
  P13 freeStyleCropEnabled;
  P14 showCropGuidelines;
  P15 showCropFrame;
  P16 hideBottomControls;
  P17 enableRotationGesture;
  P18 disableCropperColorSetters;
  P19 useFrontCamera;
  bool operator==(const NativeImageCropPickerPickerOptions &other) const {
    return mediaType == other.mediaType && multiple == other.multiple && includeBase64 == other.includeBase64 && includeExif == other.includeExif && cropping == other.cropping && width == other.width && height == other.height && cropperActiveWidgetColor == other.cropperActiveWidgetColor && cropperStatusBarColor == other.cropperStatusBarColor && cropperToolbarColor == other.cropperToolbarColor && cropperToolbarTitle == other.cropperToolbarTitle && cropperToolbarWidgetColor == other.cropperToolbarWidgetColor && cropperCircleOverlay == other.cropperCircleOverlay && freeStyleCropEnabled == other.freeStyleCropEnabled && showCropGuidelines == other.showCropGuidelines && showCropFrame == other.showCropFrame && hideBottomControls == other.hideBottomControls && enableRotationGesture == other.enableRotationGesture && disableCropperColorSetters == other.disableCropperColorSetters && useFrontCamera == other.useFrontCamera;
  }
};

template <typename T>
struct NativeImageCropPickerPickerOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mediaType)>(rt, value.getProperty(rt, "mediaType"), jsInvoker),
      bridging::fromJs<decltype(types.multiple)>(rt, value.getProperty(rt, "multiple"), jsInvoker),
      bridging::fromJs<decltype(types.includeBase64)>(rt, value.getProperty(rt, "includeBase64"), jsInvoker),
      bridging::fromJs<decltype(types.includeExif)>(rt, value.getProperty(rt, "includeExif"), jsInvoker),
      bridging::fromJs<decltype(types.cropping)>(rt, value.getProperty(rt, "cropping"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.cropperActiveWidgetColor)>(rt, value.getProperty(rt, "cropperActiveWidgetColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperStatusBarColor)>(rt, value.getProperty(rt, "cropperStatusBarColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarColor)>(rt, value.getProperty(rt, "cropperToolbarColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarTitle)>(rt, value.getProperty(rt, "cropperToolbarTitle"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarWidgetColor)>(rt, value.getProperty(rt, "cropperToolbarWidgetColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperCircleOverlay)>(rt, value.getProperty(rt, "cropperCircleOverlay"), jsInvoker),
      bridging::fromJs<decltype(types.freeStyleCropEnabled)>(rt, value.getProperty(rt, "freeStyleCropEnabled"), jsInvoker),
      bridging::fromJs<decltype(types.showCropGuidelines)>(rt, value.getProperty(rt, "showCropGuidelines"), jsInvoker),
      bridging::fromJs<decltype(types.showCropFrame)>(rt, value.getProperty(rt, "showCropFrame"), jsInvoker),
      bridging::fromJs<decltype(types.hideBottomControls)>(rt, value.getProperty(rt, "hideBottomControls"), jsInvoker),
      bridging::fromJs<decltype(types.enableRotationGesture)>(rt, value.getProperty(rt, "enableRotationGesture"), jsInvoker),
      bridging::fromJs<decltype(types.disableCropperColorSetters)>(rt, value.getProperty(rt, "disableCropperColorSetters"), jsInvoker),
      bridging::fromJs<decltype(types.useFrontCamera)>(rt, value.getProperty(rt, "useFrontCamera"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String mediaTypeToJs(jsi::Runtime &rt, decltype(types.mediaType) value) {
    return bridging::toJs(rt, value);
  }

  static bool multipleToJs(jsi::Runtime &rt, decltype(types.multiple) value) {
    return bridging::toJs(rt, value);
  }

  static bool includeBase64ToJs(jsi::Runtime &rt, decltype(types.includeBase64) value) {
    return bridging::toJs(rt, value);
  }

  static bool includeExifToJs(jsi::Runtime &rt, decltype(types.includeExif) value) {
    return bridging::toJs(rt, value);
  }

  static bool croppingToJs(jsi::Runtime &rt, decltype(types.cropping) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperActiveWidgetColorToJs(jsi::Runtime &rt, decltype(types.cropperActiveWidgetColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperStatusBarColorToJs(jsi::Runtime &rt, decltype(types.cropperStatusBarColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarColorToJs(jsi::Runtime &rt, decltype(types.cropperToolbarColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarTitleToJs(jsi::Runtime &rt, decltype(types.cropperToolbarTitle) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarWidgetColorToJs(jsi::Runtime &rt, decltype(types.cropperToolbarWidgetColor) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperCircleOverlayToJs(jsi::Runtime &rt, decltype(types.cropperCircleOverlay) value) {
    return bridging::toJs(rt, value);
  }

  static bool freeStyleCropEnabledToJs(jsi::Runtime &rt, decltype(types.freeStyleCropEnabled) value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropGuidelinesToJs(jsi::Runtime &rt, decltype(types.showCropGuidelines) value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropFrameToJs(jsi::Runtime &rt, decltype(types.showCropFrame) value) {
    return bridging::toJs(rt, value);
  }

  static bool hideBottomControlsToJs(jsi::Runtime &rt, decltype(types.hideBottomControls) value) {
    return bridging::toJs(rt, value);
  }

  static bool enableRotationGestureToJs(jsi::Runtime &rt, decltype(types.enableRotationGesture) value) {
    return bridging::toJs(rt, value);
  }

  static bool disableCropperColorSettersToJs(jsi::Runtime &rt, decltype(types.disableCropperColorSetters) value) {
    return bridging::toJs(rt, value);
  }

  static bool useFrontCameraToJs(jsi::Runtime &rt, decltype(types.useFrontCamera) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.mediaType) {
      result.setProperty(rt, "mediaType", bridging::toJs(rt, value.mediaType.value(), jsInvoker));
    }
    if (value.multiple) {
      result.setProperty(rt, "multiple", bridging::toJs(rt, value.multiple.value(), jsInvoker));
    }
    if (value.includeBase64) {
      result.setProperty(rt, "includeBase64", bridging::toJs(rt, value.includeBase64.value(), jsInvoker));
    }
    if (value.includeExif) {
      result.setProperty(rt, "includeExif", bridging::toJs(rt, value.includeExif.value(), jsInvoker));
    }
    if (value.cropping) {
      result.setProperty(rt, "cropping", bridging::toJs(rt, value.cropping.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.height) {
      result.setProperty(rt, "height", bridging::toJs(rt, value.height.value(), jsInvoker));
    }
    if (value.cropperActiveWidgetColor) {
      result.setProperty(rt, "cropperActiveWidgetColor", bridging::toJs(rt, value.cropperActiveWidgetColor.value(), jsInvoker));
    }
    if (value.cropperStatusBarColor) {
      result.setProperty(rt, "cropperStatusBarColor", bridging::toJs(rt, value.cropperStatusBarColor.value(), jsInvoker));
    }
    if (value.cropperToolbarColor) {
      result.setProperty(rt, "cropperToolbarColor", bridging::toJs(rt, value.cropperToolbarColor.value(), jsInvoker));
    }
    if (value.cropperToolbarTitle) {
      result.setProperty(rt, "cropperToolbarTitle", bridging::toJs(rt, value.cropperToolbarTitle.value(), jsInvoker));
    }
    if (value.cropperToolbarWidgetColor) {
      result.setProperty(rt, "cropperToolbarWidgetColor", bridging::toJs(rt, value.cropperToolbarWidgetColor.value(), jsInvoker));
    }
    if (value.cropperCircleOverlay) {
      result.setProperty(rt, "cropperCircleOverlay", bridging::toJs(rt, value.cropperCircleOverlay.value(), jsInvoker));
    }
    if (value.freeStyleCropEnabled) {
      result.setProperty(rt, "freeStyleCropEnabled", bridging::toJs(rt, value.freeStyleCropEnabled.value(), jsInvoker));
    }
    if (value.showCropGuidelines) {
      result.setProperty(rt, "showCropGuidelines", bridging::toJs(rt, value.showCropGuidelines.value(), jsInvoker));
    }
    if (value.showCropFrame) {
      result.setProperty(rt, "showCropFrame", bridging::toJs(rt, value.showCropFrame.value(), jsInvoker));
    }
    if (value.hideBottomControls) {
      result.setProperty(rt, "hideBottomControls", bridging::toJs(rt, value.hideBottomControls.value(), jsInvoker));
    }
    if (value.enableRotationGesture) {
      result.setProperty(rt, "enableRotationGesture", bridging::toJs(rt, value.enableRotationGesture.value(), jsInvoker));
    }
    if (value.disableCropperColorSetters) {
      result.setProperty(rt, "disableCropperColorSetters", bridging::toJs(rt, value.disableCropperColorSetters.value(), jsInvoker));
    }
    if (value.useFrontCamera) {
      result.setProperty(rt, "useFrontCamera", bridging::toJs(rt, value.useFrontCamera.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeImageCropPickerPickerResponse

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct NativeImageCropPickerPickerResponse {
  P0 path;
  P1 localIdentifier;
  P2 sourceURL;
  P3 filename;
  P4 width;
  P5 height;
  P6 mime;
  P7 size;
  P8 duration;
  P9 data;
  P10 exif;
  P11 cropRect;
  P12 creationDate;
  P13 modificationDate;
  bool operator==(const NativeImageCropPickerPickerResponse &other) const {
    return path == other.path && localIdentifier == other.localIdentifier && sourceURL == other.sourceURL && filename == other.filename && width == other.width && height == other.height && mime == other.mime && size == other.size && duration == other.duration && data == other.data && exif == other.exif && cropRect == other.cropRect && creationDate == other.creationDate && modificationDate == other.modificationDate;
  }
};

template <typename T>
struct NativeImageCropPickerPickerResponseBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.path)>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<decltype(types.localIdentifier)>(rt, value.getProperty(rt, "localIdentifier"), jsInvoker),
      bridging::fromJs<decltype(types.sourceURL)>(rt, value.getProperty(rt, "sourceURL"), jsInvoker),
      bridging::fromJs<decltype(types.filename)>(rt, value.getProperty(rt, "filename"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.mime)>(rt, value.getProperty(rt, "mime"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<decltype(types.data)>(rt, value.getProperty(rt, "data"), jsInvoker),
      bridging::fromJs<decltype(types.exif)>(rt, value.getProperty(rt, "exif"), jsInvoker),
      bridging::fromJs<decltype(types.cropRect)>(rt, value.getProperty(rt, "cropRect"), jsInvoker),
      bridging::fromJs<decltype(types.creationDate)>(rt, value.getProperty(rt, "creationDate"), jsInvoker),
      bridging::fromJs<decltype(types.modificationDate)>(rt, value.getProperty(rt, "modificationDate"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String pathToJs(jsi::Runtime &rt, decltype(types.path) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String localIdentifierToJs(jsi::Runtime &rt, decltype(types.localIdentifier) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sourceURLToJs(jsi::Runtime &rt, decltype(types.sourceURL) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String filenameToJs(jsi::Runtime &rt, decltype(types.filename) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String mimeToJs(jsi::Runtime &rt, decltype(types.mime) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String dataToJs(jsi::Runtime &rt, decltype(types.data) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object exifToJs(jsi::Runtime &rt, decltype(types.exif) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object cropRectToJs(jsi::Runtime &rt, decltype(types.cropRect) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String creationDateToJs(jsi::Runtime &rt, decltype(types.creationDate) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String modificationDateToJs(jsi::Runtime &rt, decltype(types.modificationDate) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    if (value.localIdentifier) {
      result.setProperty(rt, "localIdentifier", bridging::toJs(rt, value.localIdentifier.value(), jsInvoker));
    }
    if (value.sourceURL) {
      result.setProperty(rt, "sourceURL", bridging::toJs(rt, value.sourceURL.value(), jsInvoker));
    }
    if (value.filename) {
      result.setProperty(rt, "filename", bridging::toJs(rt, value.filename.value(), jsInvoker));
    }
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "mime", bridging::toJs(rt, value.mime, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.duration) {
      result.setProperty(rt, "duration", bridging::toJs(rt, value.duration.value(), jsInvoker));
    }
    if (value.data) {
      result.setProperty(rt, "data", bridging::toJs(rt, value.data.value(), jsInvoker));
    }
    if (value.exif) {
      result.setProperty(rt, "exif", bridging::toJs(rt, value.exif.value(), jsInvoker));
    }
    if (value.cropRect) {
      result.setProperty(rt, "cropRect", bridging::toJs(rt, value.cropRect.value(), jsInvoker));
    }
    if (value.creationDate) {
      result.setProperty(rt, "creationDate", bridging::toJs(rt, value.creationDate.value(), jsInvoker));
    }
    if (value.modificationDate) {
      result.setProperty(rt, "modificationDate", bridging::toJs(rt, value.modificationDate.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeImageCropPickerCxxSpecJSI : public TurboModule {
protected:
  NativeImageCropPickerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value openPicker(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value openCamera(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value openCropper(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value clean(jsi::Runtime &rt) = 0;
  virtual jsi::Value cleanSingle(jsi::Runtime &rt, jsi::String path) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageCropPickerCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNCImageCropPicker";

protected:
  NativeImageCropPickerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageCropPickerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeImageCropPickerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageCropPickerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value openPicker(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openPicker) == 2,
          "Expected openPicker(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openPicker, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value openCamera(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openCamera) == 2,
          "Expected openCamera(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openCamera, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value openCropper(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openCropper) == 2,
          "Expected openCropper(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openCropper, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value clean(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clean) == 1,
          "Expected clean(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clean, jsInvoker_, instance_);
    }
    jsi::Value cleanSingle(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::cleanSingle) == 2,
          "Expected cleanSingle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cleanSingle, jsInvoker_, instance_, std::move(path));
    }

  private:
    friend class NativeImageCropPickerCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
